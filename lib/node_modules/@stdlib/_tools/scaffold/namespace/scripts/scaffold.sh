#!/usr/bin/env bash
#
# @license Apache-2.0
#
# Copyright (c) 2025 The Stdlib Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Script for scaffolding a namespace package.
#
# Usage: scaffold.h
#
# Environment Variables:
#
#   PKG                     Package name.
#   PKG_DESC                Package description.
#   MAIN_DESC               Main export description.
#   README_HEADING          README heading text.
#   KEYWORDS                List of keywords.
#

## USER-DEFINED VARIABLES ##

# Define the package name:
# shellcheck disable=SC2016
pkg=${PKG:-"${PKG:-'TODO'}"}

# Define the package description:
# shellcheck disable=SC2016
pkg_desc=${PKG_DESC:-"${PKG_DESC:-'TODO'}."}

# Define main export description:
# shellcheck disable=SC2016
main_desc=${MAIN_DESC:-"${MAIN_DESC:-'TODO'}."}

# Define the README heading:
# shellcheck disable=SC2016
readme_heading=${README_HEADING:-"${README_HEADING:-'TODO'}"}

# Define a list of keywords:
if [[ -z "${KEYWORDS:-}" ]]; then
keywords=(
	"TODO"
)
else
	IFS=','; read -ra keywords <<< "${KEYWORDS}"; IFS=' ';
fi


## COMPUTED VARIABLES ##

# Converts from camel case to a underscored delineated string.
#
# $1 - string to convert
camelcase_to_snakecase() {
	echo "$1" | sed 's/\([^A-Z]\)\([A-Z]\)/\1_\2/g' | sed 's/\([A-Z]\)\([A-Z]\)\([^A-Z]\)/\1_\2\3/g' | tr '[:upper:]' '[:lower:]'
}

# Determine the root project directory:
root_dir="$(git rev-parse --show-toplevel)"

# Define the project source code directory:
base_dir="${root_dir}/lib/node_modules"

# Define the destination path:
dest_dir="${base_dir}/@${pkg}"

# Define the location of this scaffold:
this_dir="${base_dir}/@stdlib/_tools/scaffold/namespace"

# Define the copyright year:
year=$(date +'%Y')

# Define the copyright holders:
copyright='The Stdlib Authors'


## SCRIPT ##

# Define the list of scaffold directories:
dirs=(
	"docs"
	"docs/types"
	"examples"
	"lib"
	"test"
)

# Define the list of scaffold files:
files=(
	"docs/types/index.d.ts"
	"docs/types/test.ts"
	"examples/index.js"
	"lib/index.js"
	"test/test.js"
	"package.json"
	"README.md"
)

# Create the destination directories...
# shellcheck disable=SC2048
for dir in ${dirs[*]}; do
	mkdir -p "${dest_dir}/${dir}"
done

# Copy the scaffold files to the destination directory...
# shellcheck disable=SC2048
for file in ${files[*]}; do
	cp "${this_dir}/data/${file//\./__}.txt" "${dest_dir}/${file}"
done

# Performs a find and replace across the destination directory.
#
# $1 - regular expression
find_and_replace() {
	find "${dest_dir}" -type f -print0 | xargs -0 perl -pi -w -e "$1"
}

# Performs a find and replace across a specified file.
#
# $1 - file
# $2 - regular expression
file_find_and_replace() {
	find "${dest_dir}/$1" -type f -print0 | xargs -0 perl -pi -w -e "$2"
}

# Joins a list of strings.
#
# $1 - separator
# $* - list of strings to join
join() {
	local d=$1; shift; local f=$1; shift; printf %s "$f" "${@/#/$d}";
}

# For each of the variables defined above, insert into the scaffold files...
regex="s/\\{\\{YEAR\\}\\}/${year}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{COPYRIGHT\\}\\}/${copyright}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{PKG\\}\\}/${pkg//\//\\/}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{PKG_DESC\\}\\}/${pkg_desc}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{MAIN_DESC\\}\\}/${main_desc}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{README_HEADING\\}\\}/${readme_heading}/g;"
find_and_replace "${regex}"

keywords_sep='",\n    "'
if [ "${#keywords[*]}" -eq 0 ]; then
	words=''
else
	words=$(join "${keywords_sep}" "${keywords[@]}")
	words="\\n    \"${words}\","
fi
regex="s/\\{\\{KEYWORDS\\}\\}/${words}/g;"
find_and_replace "${regex}"
