/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable max-len */

'use strict';

// MODULES //

var logger = require( 'debug' );
var rule = require( 'unified-lint-rule' );
var visit = require( 'unist-util-visit' );
var replace = require( '@stdlib/string/replace' );
var trim = require( '@stdlib/string/trim' );


// VARIABLES //

var debug = logger( 'remark-lint-html-section-structure' );
var RE_SECTION_START = /<section(?:\s+class="([^"]*)")?>/;
var RE_SECTION_END = /<\/section>$/;
var RE_SECTION_END_COMMENT = /<\/section>\s*<!--\s*\/\.([^*]*)\s*-->/;
var RE_END_COMMENT_SIMPLE = /<!--\s*\/\.([^>]+)-->/;
var RE_END_COMMENT = /^\s*<!--\s*\/\.([^\s]*)\s*-->/;
var RE_EMPTY_LINES = /(\r?\n)\s*(\r?\n)/;
var htmlSectionStructureRule;


// FUNCTIONS //

/**
* Creates a position string from a node's position.
*
* @private
* @param {Object} node - AST node
* @returns {string} position string in format "line:column"
*/
function formatPosition( node ) {
	return node.position.start.line + ':' + node.position.start.column;
}

/**
* Reports an error message.
*
* @private
* @param {Object} file - virtual file
* @param {Object} node - AST node to attach message to
* @param {string} message - error message
* @param {string} errorCode - error code identifier
*/
function reportErr( file, node, message, errorCode ) {
	var fullMsg = formatPosition( node ) + '   error   ' + message + '   ' + errorCode;
	debug( fullMsg );
	file.message( fullMsg, node );
}

/**
* Extracts comment class name from a node.
*
* @private
* @param {Object} node - AST node containing comment
* @param {RegExp} matchRegex - regular expression for matching comment
* @param {RegExp} simpleMatchRegex - alternative regular expression for matching comment
* @returns {(string|null)} extracted class name or null if no match
*/
function extractCommentClass( node, matchRegex, simpleMatchRegex ) {
	var simpleMatch;
	var match;

	match = matchRegex.exec( node.value );
	if ( match ) {
		return match[ 1 ];
	}

	simpleMatch = simpleMatchRegex.exec( node.value );
	if ( simpleMatch ) {
		return trim( simpleMatch[ 1 ] );
	}

	return null;
}

/**
* Validates that the class name in a comment matches the section class.
*
* @private
* @param {Object} file - virtual file
* @param {Object} node - node containing the comment
* @param {string} cClass - class name extracted from comment
* @param {string} sClass - class name from section
* @param {string} errMsg - error message to use if validation fails
* @param {string} errCode - error code to use if validation fails
* @returns {boolean} boolean indicating whether the comment class matches the section class
*/
function checkCommentClass( file, node, cClass, sClass, errMsg, errCode ) {
	if ( sClass && cClass !== sClass ) {
		debug( 'Mismatched section class in comment: expected %s, got %s', sClass, cClass );
		errMsg = replace( errMsg, '%s1', sClass );
		errMsg = replace( errMsg, '%s2', cClass );
		reportErr( file, node, errMsg, errCode );
		return false;
	}
	return true;
}

/**
* Validates if there is sufficient whitespace between nodes.
*
* @private
* @param {Object} endNode - end section node
* @param {Object} commentNode - comment node
* @returns {boolean} boolean indicating whether there is sufficient whitespace between nodes
*/
function hasValidWhitespace( endNode, commentNode ) {
	var lineGap = commentNode.position.start.line - endNode.position.end.line;
	debug( 'Gap between section end and comment: %d lines', lineGap );

	// We require at least 2 lines of gap for an empty line:
	return lineGap >= 2;
}

/**
* Checks if a text node contains proper empty line.
*
* @private
* @param {Object} node - text node to check
* @returns {boolean} boolean indicating whether the node contains proper empty line
*/
function hasEmptyLine( node ) {
	var value;

	if ( node.type !== 'text' ) {
		return false;
	}

	value = node.value;

	// Look for at least two consecutive newlines (representing an empty line):
	return RE_EMPTY_LINES.test( value );
}


// MAIN //

/**
* Validates HTML section structure in README files.
*
* @private
* @param {Node} tree - abstract syntax tree (AST)
* @param {File} file - virtual file
* @param {Object} options - options
* @param {Callback} clbk - callback to invoke upon completion
* @returns {void}
*/
function linter( tree, file, options, clbk ) {
	var rootSections;
	var sectionStack;
	var structure;
	var positions;
	var className;
	var errCode;
	var msg;
	var i;

	debug( 'Linting file: %s', file.path || '' );

	sectionStack = [];
	rootSections = [];
	structure = [];
	positions = {};

	visit( tree, 'html', visitor );

	debug( 'Final section stack length: %d', sectionStack.length );

	if ( sectionStack.length > 0 ) {
		debug( 'Found unclosed sections: %d', sectionStack.length );
		for ( i = 0; i < sectionStack.length; i++ ) {
			className = sectionStack[ i ].className || '[no class specified]';
			msg = 'Unclosed section tag. Missing </section> closing tag for section with class="' + className + '". Add a closing tag to fix.';
			errCode = 'unclosed-section';
			reportErr( file, sectionStack[ i ], msg, errCode );
		}
	}

	debug( 'Finished linting: %s', file.path || '' );
	return clbk();

	/**
	* Callback invoked upon finding a matching node.
	*
	* @private
	* @param {Object} node - AST node
	* @param {number} index - position of `node` in `parent`
	* @param {Object} parent - parent AST node
	* @returns {void}
	*/
	function visitor( node, index, parent ) {
		var combinedMatch;
		var commentClass;
		var sectionMatch;
		var commentNode;
		var nextNode;
		var endMatch;
		var current;
		var match;
		var data;

		// Store position for tracking purposes:
		if ( node.position ) {
			positions[ node.position.start.line ] = node;
		}

		// Check if this is a combined section end with comment on the same line (which is an error):
		combinedMatch = RE_SECTION_END_COMMENT.exec( node.value );
		if ( combinedMatch ) {
			debug( 'Found combined section end with comment: %s', node.value );
			msg = 'Missing empty line between closing section tag and comment. There should be an empty line between </section> and <!-- /.' + combinedMatch[1] + ' -->';
			errCode = 'missing-empty-line';
			reportErr( file, node, msg, errCode );

			// Make sure to pop the section stack for this case - otherwise we'll get "unclosed section" errors:
			if ( sectionStack.length > 0 ) {
				debug( 'Popping section stack for combined section end+comment' );
				sectionStack.pop();
			}

			// Do not fall through to other handlers once combined case is handled...
			return;
		}

		// Check if this is a section start tag:
		sectionMatch = RE_SECTION_START.exec( node.value );
		if ( sectionMatch ) {
			debug( 'Found a section start tag with class: %s', sectionMatch[1] || '[none]' );

			data = {
				'node': node,
				'className': sectionMatch[1] || '',
				'position': node.position,
				'children': [],
				'index': index,
				'parent': parent
			};

			if ( sectionStack.length === 0 ) {
				// This is a root level section...
				rootSections.push( data );
				structure.push( data );
			} else {
				// This is a nested section, add to parent's children:
				sectionStack[ sectionStack.length - 1 ].children.push( data );
			}

			sectionStack.push( data );

			// Don't fall through and misinterpret this node as an end tag...
			return;
		}

		// Check if this is a section end tag:
		endMatch = RE_SECTION_END.exec( node.value );
		if ( endMatch ) {
			debug( 'Found a section end tag' );

			if ( sectionStack.length === 0 ) {
				debug( 'Orphaned section end tag found' );
				msg = 'Orphaned section closing tag. Found </section> without a matching opening <section> tag. Remove this tag or add a corresponding opening tag.';
				errCode = 'orphaned-section-end';
				reportErr( file, node, msg, errCode );

				// Since there is nothing to close, do not fall through to other end-handling logic...
				return;
			}

			// Special handling for direct closing tag followed by a comment (no text node between)...
			if ( index + 1 < parent.children.length ) {
				nextNode = parent.children[ index + 1 ];

				// Look at the next node to check if it's a comment:
				if ( nextNode.type === 'html' ) {
					// Check if the next node is a comment but NOT on the same line
					commentClass = extractCommentClass( nextNode, RE_END_COMMENT, RE_END_COMMENT_SIMPLE );

					if ( commentClass ) {
						// Check if there are at least 2 line breaks between them:
						if ( !hasValidWhitespace( node, nextNode ) ) {
							msg = 'Missing proper empty line after closing section tag. There should be an empty line between </section> and the closing comment.';
							errCode = 'missing-empty-line-after-section';
							reportErr( file, node, msg, errCode );
						}

						// Verify the comment matches the class name:
						current = sectionStack[sectionStack.length - 1];
						msg = 'Mismatched section class in closing comment. Opening tag has class="%s1" but closing comment is <!-- /.%s2 -->. They should match.';
						errCode = 'mismatched-section-class';
						checkCommentClass( file, nextNode, commentClass, current.className, msg, errCode );

						// Pop the section stack before returning:
						sectionStack.pop();
						return;
					}
				}
			}

			// Standard handling for other cases with whitespace between section end and comment...
			if ( index + 2 < parent.children.length ) {
				nextNode = parent.children[ index + 1 ];
				commentNode = parent.children[ index + 2 ];

				// Check if the next node is a proper whitespace with empty line:
				if ( !hasEmptyLine( nextNode ) ) {
					debug( 'Invalid whitespace after section end' );
					msg = 'Missing proper empty line after closing section tag. There should be an empty line between </section> and the closing comment.';
					errCode = 'missing-empty-line-after-section';
					reportErr( file, node, msg, errCode );

					// Fall through to still check following comment and then close section...
				}

				// Check if the following node is the expected comment:
				if ( commentNode.type === 'html' ) {
					match = RE_END_COMMENT.exec( commentNode.value );
					if ( match ) {
						current = sectionStack[ sectionStack.length - 1 ];
						msg = 'Mismatched section class in closing comment. Opening tag has class="%s1" but closing comment is <!-- /.%s2 -->. They should match.';
						errCode = 'mismatched-section-class';
						checkCommentClass( file, commentNode, match[1], current.className, msg, errCode );
					} else {
						// The HTML node exists but it's not a proper closing comment...
						debug( 'Invalid closing comment format' );
						msg = 'Invalid section closing comment format. Expected <!-- /.' + sectionStack[ sectionStack.length - 1 ].className + ' -->';
						errCode = 'invalid-closing-comment';
						reportErr( file, commentNode, msg, errCode );
					}
				} else {
					// The node after whitespace is not an HTML node (comment)...
					debug( 'Node after whitespace is not an HTML comment' );
					msg = 'Missing section closing comment. Section closing tag should be followed by <!-- /.' + sectionStack[ sectionStack.length - 1 ].className + ' --> comment.';
					errCode = 'missing-section-comment';
					reportErr( file, node, msg, errCode );
				}

				sectionStack.pop();
				return;
			}

			// There's not enough nodes after the section closing tag...
			debug( 'Not enough nodes after section end' );
			msg = 'Missing section closing comment. Section closing tag should be followed by <!-- /.' + sectionStack[ sectionStack.length - 1 ].className + ' --> comment on a separate line.';
			errCode = 'missing-section-comment';
			reportErr( file, node, msg, errCode );
			sectionStack.pop();
		}
	}
}

htmlSectionStructureRule = rule( 'remark-lint:html-section-structure', linter );


// EXPORTS //

module.exports = htmlSectionStructureRule;
