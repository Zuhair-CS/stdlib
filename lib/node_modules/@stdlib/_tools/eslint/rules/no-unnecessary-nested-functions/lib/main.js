/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// VARIABLES //

var rule;


// FUNCTIONS //

/**
* Checks if a function is inside an IIFE (Immediately Invoked Function Expression).
*
* @private
* @param {ASTNode} node - function declaration node
* @returns {boolean} true if function is inside an IIFE
*/
function isInsideIIFE( node ) {
	var parent = node.parent;

	// Walk up the AST to check if we're inside an IIFE...
	while ( parent ) {
		// Check if parent is a function expression or arrow function:
		if ( parent.type === 'FunctionExpression' || parent.type === 'ArrowFunctionExpression' ) {
			// Check if the function's parent is a CallExpression (making it an IIFE):
			if ( parent.parent && parent.parent.type === 'CallExpression' && parent.parent.callee === parent ) {
				return true;
			}
		}
		parent = parent.parent;
	}

	return false;
}

/**
* Determines if a function or any of its nested functions reference variables from outer scopes.
*
* @private
* @param {ASTNode} node - function declaration node
* @param {Object} context - ESLint context
* @returns {boolean} true if function or nested functions reference outer scope variables
*/
function referencesOuterVariables( node, context ) {
	var identifierName;
	var sourceCode;
	var checkScope;
	var reference;
	var variables;
	var variable;
	var found;
	var scope;
	var stmt;
	var i;
	var j;

	sourceCode = context.getSourceCode();
	scope = sourceCode.getScope( node );

	// Check all references in this scope...
	for ( i = 0; i < scope.references.length; i++ ) {
		reference = scope.references[ i ];
		variable = reference.resolved;
		identifierName = reference.identifier.name;

		// If variable is resolved and not in current scope, it's from outer scope...
		if ( variable && variable.scope !== scope ) {
			// Make sure it's not a global or built-in:
			if ( variable.scope.type !== 'global' ) {
				return true;
			}
		}

		// Handle unresolved references that might be from outer scope...
		if ( !variable ) {
			// Check if this identifier exists in parent scopes...
			checkScope = scope.upper;
			while ( checkScope && checkScope.type !== 'global' ) {
				variables = checkScope.variables;
				found = false;
				for ( j = 0; j < variables.length; j++ ) {
					if ( variables[ j ].name === identifierName ) {
						found = true;
						break;
					}
				}
				if ( found ) {
					return true;
				}
				checkScope = checkScope.upper;
			}
		}
	}

	// Also check nested functions within this function...
	if ( node.body && node.body.body ) {
		for ( i = 0; i < node.body.body.length; i++ ) {
			stmt = node.body.body[i];
			if ( stmt.type === 'FunctionDeclaration' ) {
				if ( referencesOuterVariables( stmt, context ) ) {
					return true;
				}
			}
		}
	}

	return false;
}

/**
* Finds the scope where a variable is defined.
*
* @private
* @param {string} varName - variable name
* @param {Object} startScope - scope to start searching from
* @returns {(Object|null)} scope where variable is defined or null if not found
*/
function findVariableScope( varName, startScope ) {
	var currentScope;
	var variables;
	var i;

	currentScope = startScope;

	while ( currentScope && currentScope.type !== 'global' ) {
		variables = currentScope.variables;
		for ( i = 0; i < variables.length; i++ ) {
			if ( variables[i].name === varName ) {
				return currentScope;
			}
		}
		currentScope = currentScope.upper;
	}

	return null;
}

/**
* Determines the highest scope where a function can be moved based on its variable references.
*
* @private
* @param {ASTNode} node - function declaration node
* @param {Object} context - ESLint context
* @returns {(Object|null)} highest scope object or null if cannot be moved
*/
function getHighestPossibleScope( node, context ) {
	var definingScope;
	var highestScope;
	var currentScope;
	var sourceCode;
	var checkScope;
	var reference;
	var variable;
	var varScope;
	var i;

	sourceCode = context.getSourceCode();
	currentScope = sourceCode.getScope( node );

	// Start with the assumption we can move all the way to module level (just below global)...
	highestScope = currentScope.upper;
	while ( highestScope && highestScope.upper && highestScope.upper.type !== 'global' ) {
		highestScope = highestScope.upper;
	}

	// If we're already at module level, we still want to check if we can move there (note: this handles the case where the function is directly nested in a top-level function)...

	// Check all references in this function's scope...
	for ( i = 0; i < currentScope.references.length; i++ ) {
		reference = currentScope.references[ i ];
		variable = reference.resolved;

		// If variable is resolved and not in current scope, find where it's defined...
		if ( variable && variable.scope !== currentScope && variable.scope.type !== 'global' ) {
			// Can't move higher than the scope where this variable is defined...
			varScope = variable.scope;

			// Walk up the scope chain to see if the variable scope is an ancestor...
			checkScope = currentScope.upper;
			while ( checkScope && checkScope !== varScope && checkScope.type !== 'global' ) {
				checkScope = checkScope.upper;
			}

			// If we found the variable scope in our ancestor chain, restrict to that level:
			if ( checkScope === varScope ) {
				highestScope = varScope;
			}
		}

		// Handle unresolved references...
		if ( !variable ) {
			definingScope = findVariableScope( reference.identifier.name, currentScope.upper ); // eslint-disable-line max-len
			if ( definingScope ) {
				// Can't move higher than where this variable is defined...
				if ( definingScope === currentScope.upper ) {
					highestScope = currentScope.upper;
				}
			}
		}
	}

	// Always return the highest scope - let the caller decide if it should report:
	return highestScope;
}

/**
* Determines the scope type name for error messages.
*
* @private
* @param {Object} scope - ESLint scope object
* @returns {string} scope type name for messages
*/
function getScopeTypeName( scope ) {
	if ( scope.type === 'module' ) {
		return 'module scope';
	}
	if ( scope.type === 'function' ) {
		return 'outer function scope';
	}
	return 'higher scope';
}

/**
* Rule for enforcing that inner function declarations are moved to higher scope when possible.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	/**
	* Checks if a function declaration can be moved to a higher scope.
	*
	* @private
	* @param {ASTNode} node - function declaration node
	*/
	function checkFunctionDeclaration( node ) {
		var scopeTypeName;
		var highestScope;
		var sourceCode;
		var canMove;
		var scope;

		// Skip functions inside IIFEs as they are intentionally isolated:
		if ( isInsideIIFE( node ) ) {
			return;
		}

		sourceCode = context.getSourceCode();
		scope = sourceCode.getScope( node );

		// Skip if already at module/global scope:
		if ( !scope.upper || scope.upper.type === 'global' || scope.upper.type === 'module' ) {
			return;
		}

		highestScope = getHighestPossibleScope( node, context );
		if ( highestScope ) {
			canMove = false;

			// Check if the function can be moved to a higher scope...
			if ( !referencesOuterVariables( node, context ) ) {
				// Function doesn't reference outer variables, can move to module scope...
				canMove = true;
				scopeTypeName = ( highestScope.upper && highestScope.upper.type === 'global' ) ? 'module scope' : getScopeTypeName( highestScope );
			} else if ( highestScope !== scope.upper ) {
				// References outer variables but can still move higher than current level...
				canMove = true;
				scopeTypeName = getScopeTypeName( highestScope );
			}

			if ( canMove ) {
				context.report({
					'node': node,
					'message': 'Function \'{{name}}\' should be moved to {{scope}}.',
					'data': {
						'name': ( node.id ) ? node.id.name : '<anonymous>',
						'scope': scopeTypeName
					}
				});
			}
		}
	}

	return {
		'FunctionDeclaration': checkFunctionDeclaration
	};
}


// MAIN //

rule = {
	'meta': {
		'type': 'suggestion',
		'docs': {
			'description': 'enforce moving inner function declarations to higher scope when they do not depend on outer scope variables'
		},
		'schema': []
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
