/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// VARIABLES //

var rule;


// FUNCTIONS //

/**
* Returns a scope object for a given AST node.
*
* @private
* @param {Object} context - ESLint rule context
* @param {Node} node - AST node
* @returns {(Object|null)} scope
*/
function getScopeByNode( context, node ) {
	var scopes = context.getSourceCode().scopeManager.scopes;
	var i;
	for ( i = scopes.length-1; i >= 0; i-- ) {
		if ( scopes[ i ].block === node ) {
			return scopes[ i ];
		}
	}
	return null;
}

/**
* Returns the nearest ancestor "function" scope for a given scope.
*
* @private
* @param {Object} scope - a scope
* @returns {(Object|null)} nearest function/global/module scope
*/
function getNearestFunctionScope( scope ) {
	var s = scope;
	while ( s ) {
		if ( s.type === 'function' || s.type === 'global' || s.type === 'module' ) {
			return s;
		}
		s = s.upper;
	}
	return null;
}

/**
* Returns whether scope `a` is within (i.e., a descendant of) scope `b`.
*
* @private
* @param {Object} a - candidate descendant scope
* @param {Object} b - candidate ancestor scope
* @returns {boolean} boolean indicating whether `a` is within `b`
*/
function isWithinScope( a, b ) {
	var s = a;
	while ( s ) {
		if ( s === b ) {
			return true;
		}
		s = s.upper;
	}
	return false;
}

/**
* Detects whether a node is inside an IIFE (Immediately Invoked Function Expression).
*
* @private
* @param {Node} node - AST node
* @returns {boolean} boolean indicating whether node is inside an IIFE
*/
function isInsideIIFE( node ) {
	var p = node.parent;
	while ( p ) {
		if ( p.type === 'FunctionExpression' || p.type === 'ArrowFunctionExpression' ) {
			if ( p.parent && p.parent.type === 'CallExpression' && p.parent.callee === p ) {
				return true;
			}
		}
		p = p.parent;
	}
	return false;
}

/**
* Collects all descendant function scopes (recursively) of a given scope.
*
* @private
* @param {Object} scope - scope to search under
* @param {Array} out - accumulator array to receive function scopes
*/
function collectDescendantFnScopes( scope, out ) {
	var child;
	var i;
	for ( i = 0; i < scope.childScopes.length; i++ ) {
		child = scope.childScopes[ i ];
		if ( child.type === 'function' ) {
			out.push( child );
		}
		collectDescendantFnScopes( child, out );
	}
}

/**
* Returns true if any nested function within `scope` depends on a variable outside of `scope` (non-global), which would break if `scope` were moved.
*
* @private
* @param {Object} scope - function scope of the candidate parent function
* @returns {boolean} boolean indicating whether an internal nested function blocks moving.
*/
function hasNestedFnDepOnOuter( scope ) {
	var variable;
	var depScope;
	var nested;
	var refs;
	var ref;
	var i;
	var j;

	nested = [];
	collectDescendantFnScopes( scope, nested );
	for ( i = 0; i < nested.length; i++ ) {
		refs = nested[ i ].through;
		for ( j = 0; j < refs.length; j++ ) {
			ref = refs[ j ];
			variable = ref.resolved;
			if ( !variable ) {
				// Likely a global/builtin: ignore
				continue;
			}
			depScope = variable.scope;
			if ( depScope.type === 'global' || depScope.type === 'module' ) {
				continue;
			}
			// If the dependency scope is not within the current scope, moving current scope would break the nested fn:
			if ( !isWithinScope( depScope, scope ) ) {
				return true;
			}
		}
	}
	return false;
}

/**
* Handler for FunctionDeclaration nodes.
*
* @private
* @param {Object} context - ESLint context
* @returns {Function} function declaration checker
*/
function checkFnDeclFactory( context ) {
	/**
	* Checks function declaration node.
	*
	* @private
	* @param {Node} node - function declaration node
	*/
	function checkFunctionDeclaration( node ) {
		var usesAncestorBeyondParent;
		var usesImmediateParent;
		var parentFnScope;
		var variable;
		var depScope;
		var fnScope;
		var name;
		var refs;
		var ref;
		var i;

		// Ignore top-level:
		if ( node.parent && node.parent.type === 'Program' ) {
			return;
		}
		// Ignore functions declared inside IIFEs:
		if ( isInsideIIFE( node ) ) {
			return;
		}

		// Acquire this function's scope:
		fnScope = getScopeByNode( context, node );
		if ( !fnScope ) {
			return;
		}
		parentFnScope = getNearestFunctionScope( fnScope.upper );

		// Classify outer dependencies for this function:
		usesImmediateParent = false;
		usesAncestorBeyondParent = false;
		refs = fnScope.through; // references that go outside this function's scope
		for ( i = 0; i < refs.length; i++ ) {
			ref = refs[ i ];
			variable = ref.resolved;
			if ( !variable ) {
				// global/builtin/undeclared -> allowed (doesn't force nesting)
				continue;
			}
			depScope = variable.scope;
			if ( depScope.type === 'global' || depScope.type === 'module' ) {
				// Refers to program scope -> allowed to hoist to module
				continue;
			}
			if ( parentFnScope && isWithinScope( depScope, parentFnScope ) ) {
				// Depends on immediate parent function (or blocks within it) -> nesting is necessary:
				usesImmediateParent = true;
				break;
			}
			// Depends on an ancestor *beyond* the immediate parent (e.g., grandparent function):
			usesAncestorBeyondParent = true;
		}

		if ( usesImmediateParent ) {
			// This function requires its current parent scope; do not report:
			return;
		}

		name = ( node.id && node.id.name ) ? node.id.name : '<anonymous>';

		if ( usesAncestorBeyondParent ) {
			// Can be hoisted out of the immediate parent and into an outer function scope:
			context.report({
				'node': node,
				'message': 'Function \'' + name + '\' should be moved to outer function scope.'
			});
			return;
		}

		// No ancestor function dependencies => candidate to move to module scope.
		// Be conservative: if any nested function relies on variables outside of this function,
		// Moving this function would break that nested function; in such a case, do not report.
		if ( hasNestedFnDepOnOuter( fnScope ) ) {
			return;
		}

		context.report({
			'node': node,
			'message': 'Function \'' + name + '\' should be moved to module scope.'
		});
	}
	return checkFunctionDeclaration;
}

/**
* Rule for enforcing that inner function declarations are moved to higher scope when possible.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	return {
		'FunctionDeclaration:exit': checkFnDeclFactory( context )
	};
}


// MAIN //

rule = {
	'meta': {
		'type': 'suggestion',
		'docs': {
			'description': 'enforce moving inner function declarations to higher scope when they do not depend on outer scope variables'
		},
		'schema': []
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
