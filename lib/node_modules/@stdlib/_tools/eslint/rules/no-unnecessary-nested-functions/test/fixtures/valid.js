/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

var valid = [];

// Top-level function (no nesting):
var test = {
	'code': [
		'function topLevel() {',
		'  return 42;',
		'}'
	].join( '\n' )
};
valid.push( test );

// Function expression (not a declaration):
test = {
	'code': [
		'function outer() {',
		'  var helper = function() {',
		'    return 42;',
		'  };',
		'  return helper();',
		'}'
	].join( '\n' )
};
valid.push( test );

// Arrow function (not a declaration):
test = {
	'code': [
		'function outer() {',
		'  var helper = () => 42;',
		'  return helper();',
		'}'
	].join( '\n' ),
	'parserOptions': {
		'ecmaVersion': 6
	}
};
valid.push( test );

// Function uses outer scope variable:
test = {
	'code': [
		'function outer( x ) {',
		'  var multiplier = 2;',
		'  function helper() {',
		'    return x * multiplier;',
		'  }',
		'  return helper();',
		'}'
	].join( '\n' )
};
valid.push( test );

// Function uses parameter from outer function:
test = {
	'code': [
		'function outer( x, y ) {',
		'  function helper() {',
		'    return x + y;',
		'  }',
		'  return helper();',
		'}'
	].join( '\n' )
};
valid.push( test );

// Function uses 'this' from outer scope:
test = {
	'code': [
		'function outer() {',
		'  var self = this;',
		'  function helper() {',
		'    return self.value;',
		'  }',
		'  return helper();',
		'}'
	].join( '\n' )
};
valid.push( test );

// Function uses 'arguments' from outer scope:
test = {
	'code': [
		'function outer() {',
		'  var args = arguments;',
		'  function helper() {',
		'    return args.length;',
		'  }',
		'  return helper();',
		'}'
	].join( '\n' )
};
valid.push( test );

// Closure pattern (uses outer variable):
test = {
	'code': [
		'function createCounter() {',
		'  var count = 0;',
		'  function increment() {',
		'    count += 1;',
		'    return count;',
		'  }',
		'  return increment;',
		'}'
	].join( '\n' )
};
valid.push( test );

// Recursive function that references itself:
test = {
	'code': [
		'function outer() {',
		'  var n = 10;',
		'  function factorial() {',
		'    if ( n <= 1 ) {',
		'      return 1;',
		'    }',
		'    n -= 1;',
		'    return n * factorial();',
		'  }',
		'  return factorial();',
		'}'
	].join( '\n' )
};
valid.push( test );

// Module-level function:
test = {
	'code': [
		'var x = 10;',
		'function moduleLevel() {',
		'  return x * 2;',
		'}'
	].join( '\n' )
};
valid.push( test );

// Mutually recursive functions:
test = {
	'code': [
		'function outer() {',
		'  var count = 0;',
		'  function even() {',
		'    if ( count === 10 ) {',
		'      return true;',
		'    }',
		'    count += 1;',
		'    return odd();',
		'  }',
		'  function odd() {',
		'    if ( count === 10 ) {',
		'      return false;',
		'    }',
		'    count += 1;',
		'    return even();',
		'  }',
		'  return even();',
		'}'
	].join( '\n' )
};
valid.push( test );

// Function references outer function before it's defined (hoisting):
test = {
	'code': [
		'function outer() {',
		'  var x = 10;',
		'  function helper() {',
		'    return x + later();',
		'  }',
		'  function later() {',
		'    return x * 2;',
		'  }',
		'  return helper();',
		'}'
	].join( '\n' )
};
valid.push( test );

// Benchmark factory pattern - valid closure over x:
test = {
	'code': [
		'function createBenchmark( len ) {',
		'  var x = new Array( len );',
		'  return benchmark;',
		'',
		'  function benchmark( b ) {',
		'    var o;',
		'    var i;',
		'',
		'    b.tic();',
		'    for ( i = 0; i < b.iterations; i++ ) {',
		'      o = process( x );',
		'      if ( typeof o !== "object" ) {',
		'        b.fail( "should return an object" );',
		'      }',
		'    }',
		'    b.toc();',
		'    b.pass( "benchmark finished" );',
		'    b.end();',
		'  }',
		'}'
	].join( '\n' )
};
valid.push( test );

// Factory returning closure - valid closure over index and array:
test = {
	'code': [
		'function createIterator( array ) {',
		'  var index = 0;',
		'  return next;',
		'',
		'  function next() {',
		'    if ( index < array.length ) {',
		'      return array[ index++ ];',
		'    }',
		'    return undefined;',
		'  }',
		'}'
	].join( '\n' )
};
valid.push( test );

// Test with multiple closures - valid closures over shared:
test = {
	'code': [
		'function setupTests() {',
		'  var shared = {};',
		'',
		'  function beforeEach() {',
		'    shared.value = Math.random();',
		'  }',
		'',
		'  function afterEach() {',
		'    shared.value = null;',
		'  }',
		'',
		'  function runTest() {',
		'    return shared.value * 2;',
		'  }',
		'',
		'  return {',
		'    beforeEach: beforeEach,',
		'    afterEach: afterEach,',
		'    runTest: runTest',
		'  };',
		'}'
	].join( '\n' )
};
valid.push( test );

// Try-function pattern - function returned immediately that closes over outer variables:
test = {
	'code': [
		'function wrap( fcn, thisArg ) {',
		'  var ctx;',
		'  if ( !isFunction( fcn ) ) {',
		'    throw new TypeError( "invalid argument" );',
		'  }',
		'  if ( arguments.length > 1 ) {',
		'    ctx = thisArg;',
		'  } else {',
		'    ctx = null;',
		'  }',
		'  return wrapped;',
		'',
		'  function wrapped() {',
		'    var args;',
		'    var len;',
		'    var i;',
		'',
		'    len = arguments.length;',
		'    args = [];',
		'    for ( i = 0; i < len; i++ ) {',
		'      args.push( arguments[ i ] );',
		'    }',
		'    try {',
		'      return fcn.apply( ctx, args );',
		'    } catch ( error ) {',
		'      if ( isError( error ) ) {',
		'        return error;',
		'      }',
		'      // Handle thrown literals...',
		'      if ( typeof error === "object" ) {',
		'        return new Error( JSON.stringify( error ) );',
		'      }',
		'      return new Error( error.toString() );',
		'    }',
		'  }',
		'}'
	].join( '\n' )
};
valid.push( test );

// Curry pattern - function returned immediately that closes over outer variables:
test = {
	'code': [
		'function curry( fcn, arity, thisArg ) {',
		'  var args;',
		'  var len;',
		'  var i;',
		'',
		'  args = [];',
		'  if ( arguments.length > 2 ) {',
		'    len = arguments.length;',
		'    for ( i = 3; i < len; i++ ) {',
		'      args.push( arguments[ i ] );',
		'    }',
		'  }',
		'  return curried;',
		'',
		'  function curried() {',
		'    var cargs;',
		'    var j;',
		'',
		'    cargs = args.slice();',
		'    for ( j = 0; j < arguments.length; j++ ) {',
		'      cargs.push( arguments[ j ] );',
		'    }',
		'    if ( cargs.length < arity ) {',
		'      return curry.apply( null, [ fcn, arity, thisArg ].concat( cargs ) );',
		'    }',
		'    return fcn.apply( thisArg, cargs );',
		'  }',
		'}'
	].join( '\n' )
};
valid.push( test );

// Curry-right pattern with nested closures - createCurried and curried functions:
test = {
	'code': [
		'function curryRight( fcn, arity, thisArg ) {',
		'  var context;',
		'  var len;',
		'  if ( arguments.length > 2 ) {',
		'    len = arity;',
		'    context = thisArg;',
		'  } else {',
		'    len = fcn.length;',
		'    context = arity;',
		'  }',
		'  return createCurried( [] );',
		'',
		'  function createCurried( args ) {',
		'    return curried;',
		'',
		'    function curried( v ) {',
		'      var cargs = args.slice();',
		'      cargs.unshift( v );',
		'      if ( cargs.length < len ) {',
		'        return createCurried( cargs );',
		'      }',
		'      return fcn.apply( context, cargs );',
		'    }',
		'  }',
		'}'
	].join( '\n' )
};
valid.push( test );


// EXPORTS //

module.exports = valid;
